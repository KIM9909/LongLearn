# 1. 프로세스 상태 (Process State)

## 1.1 프로세스 상태 개념

![alt text](<프로세스 상태도.jpg>)

### **프로세스의 5가지 상태 (Five-State Model)**

**새로운 상태 (New)**:

- **정의**: 프로세스가 생성 중인 상태
- **특징**: 프로세스가 생성되었지만 아직 OS에 의해 승인(admit) 받지 못한 상태
- **위치**: 아직 메모리에 완전히 로드되지 않음

**준비 상태 (Ready)**:

- **정의**: CPU 할당을 기다리는 상태
- **특징**: CPU를 제외한 모든 자원이 준비완료된 상태
- **특성**: 여러 개의 프로세스가 동시에 이 상태를 가질 수 있음

**실행 상태 (Running)**:

- **정의**: CPU를 할당받아 명령어가 실행 중인 상태
- **특징**: 단일 처리기에서는 오직 하나의 프로세스만 이 상태를 가짐
- **위치**: CPU 코어에서 실제 실행

**대기 상태 (Waiting/Blocked)**:

- **정의**: 특정 사건(이벤트)이 일어나기를 기다리는 상태
- **특징**: I/O 작업 완료, 자원 할당 등을 기다림
- **특성**: CPU를 반납한 상태

**종료 상태 (Terminated)**:

- **정의**: 프로세스 실행이 완료된 상태
- **특징**: 할당된 모든 자원을 반납
- **결과**: 시스템에서 제거됨

## 1.2 프로세스 상태 전이

![alt text](<프로세스 상태도-1.jpg>)

### **상태 전이 과정**

```
New → Ready: admit (OS가 프로세스를 승인)
Ready → Running: dispatch (CPU 할당)
Running → Ready: interrupt (시간 할당량 초과)
Running → Waiting: event wait (I/O 요청)
Waiting → Ready: event completion (I/O 완료)
Running → Terminated: exit (프로세스 종료)
```

### **상태 전이 상황**

1. **New → Ready**: OS가 새 프로세스를 메모리에 적재하고 승인
2. **Ready → Running**: 스케줄러가 CPU를 할당
3. **Running → Ready**: 타임 슬라이스 종료로 인한 선점
4. **Running → Waiting**: I/O 요청, 자원 대기
5. **Waiting → Ready**: I/O 완료, 자원 할당 완료
6. **Running → Terminated**: 프로세스 정상 종료 또는 강제 종료

# 2. 프로세스 제어 블록 (PCB)

## 2.1 PCB의 역할

<img src="images\PCB 구조도.png" width="500" height="400"/>

### **PCB 구성 요소**

- **프로세스 ID (PID)**: 프로세스 고유 식별자
- **프로세스 상태**: 현재 프로세스의 상태 정보
- **CPU 레지스터**: 컨텍스트 스위칭 시 저장할 레지스터 값
- **메모리 관리 정보**: 메모리 주소 공간, 페이지 테이블
- **스케줄링 정보**: 우선순위, 스케줄링 큐 포인터
- **입출력 정보**: 할당된 I/O 장치, 파일 목록

## 2.2 컨텍스트 스위칭

### **컨텍스트 스위칭 과정**

1. **현재 프로세스 상태 저장**: PCB에 레지스터 값 저장
2. **다음 프로세스 선택**: 스케줄러가 실행할 프로세스 결정
3. **새 프로세스 상태 복원**: PCB에서 레지스터 값 로드
4. **프로세스 실행 재개**: 새 프로세스가 CPU 점유

# 3. CPU 스케줄링 (CPU Scheduling)

## 3.1 스케줄링 개념

### **스케줄링의 목적**

- **CPU 이용률 극대화**: CPU가 유휴 상태가 되지 않도록 관리
- **처리량 극대화**: 단위 시간당 완료되는 프로세스 수 증가
- **응답 시간 최소화**: 대화형 시스템에서 빠른 응답
- **대기 시간 최소화**: 준비 큐에서의 대기 시간 단축
- **공정성 보장**: 모든 프로세스에게 공평한 CPU 할당

## 3.2 스케줄링 분류

### **선점 vs 비선점 스케줄링**

![alt text](<선점-비선점 스케줄링.jpg>)

**선점 스케줄링 (Preemptive)**:

- **특징**: OS가 강제로 CPU를 회수할 수 있음
- **장점**: 응답 시간 개선, 실시간 시스템 적합
- **단점**: 컨텍스트 스위칭 오버헤드, 복잡한 구현
- **적용**: 시분할 시스템, 실시간 시스템

**비선점 스케줄링 (Non-preemptive)**:

- **특징**: 프로세스가 자발적으로 CPU를 반납할 때까지 실행
- **장점**: 구현 간단, 컨텍스트 스위칭 오버헤드 적음
- **단점**: 응답 시간 예측 어려움, 대화형 시스템 부적합
- **적용**: 일괄 처리 시스템

# 4. 스케줄링 알고리즘

## 4.1 선점 스케줄링 알고리즘

### **RR (Round Robin)**

<img src="images\RR 스케줄링.jpg" width="700" height="300"/>

**특징**:

- **원리**: 고정된 시간 할당량(Time Quantum)으로 순환 실행
- **장점**: 응답 시간 개선, 공정성
- **단점**: 시간 할당량 설정이 성능에 큰 영향

**시간 할당량 선택**:

- **너무 크면**: FCFS와 유사
- **너무 작으면**: 컨텍스트 스위칭 오버헤드 증가

### **SRTF (Shortest Remaining Time First)**

**특징**:

- **원리**: SJF의 선점 버전, 남은 실행 시간이 가장 짧은 프로세스 실행
- **장점**: 평균 대기 시간 최소
- **단점**: 실행 시간 예측 필요, 기아 현상

### **다단계 큐 (Multi-Level Queue)**

**특징**:

- **구조**: 여러 개의 준비 큐를 우선순위별로 분리
- **예시**:
  - 시스템 프로세스 (최고 우선순위)
  - 대화형 프로세스 (중간 우선순위)
  - 일괄 처리 프로세스 (낮은 우선순위)

## 4.2 비선점 스케줄링 알고리즘

### **FCFS (First-Come, First-Served)**

<img src="images\FCFS 스케줄링.png" width="600" height="300"/>

**특징**:

- **원리**: 먼저 도착한 프로세스가 먼저 CPU 할당
- **구현**: 큐(Queue) 자료구조 사용
- **장점**: 구현 간단, 공정성
- **단점**: 평균 대기 시간이 길 수 있음 (Convoy Effect)

**실생활 예시**: 은행 창구 대기줄, 식당 줄서기

### **SJF (Shortest Job First)**

**특징**:

- **원리**: 실행 시간이 가장 짧은 프로세스 우선 실행
- **장점**: 평균 대기 시간 최소화 (이론적 최적)
- **단점**: 실행 시간 예측 어려움, 기아 현상 가능

**문제점**: 긴 작업이 무한정 대기할 수 있음

### **우선순위 스케줄링 (Priority Scheduling)**

**특징**:

- **원리**: 높은 우선순위 프로세스 먼저 실행
- **구현**: 우선순위 큐 사용
- **해결책**: 에이징(Aging) 기법으로 기아 현상 방지

# 핵심 요약

## **프로세스 상태**

- **5가지 상태**: New → Ready → Running → Waiting → Terminated
- **상태 전이**: 스케줄링과 이벤트에 의해 발생
- **관리**: PCB를 통한 프로세스 정보 저장

## **스케줄링 분류**

- **비선점**: FCFS, SJF, 우선순위 (일괄 처리 적합)
- **선점**: RR, SRTF, MLFQ (대화형 시스템 적합)

## **성능 최적화**

- **목표**: CPU 이용률↑, 응답시간↓, 처리량↑
- **트레이드오프**: 각 알고리즘은 장단점 존재
- **현실**: 여러 알고리즘을 조합하여 사용
